//! This build script traverses the contents of the `routes/` directory, and
//! automatically populates our crate's `Cargo.toml` manifest so that each route
//! we declare will be built into its own independent binary.
//!
//! This allows us to deploy the routes as independent serverless functions,
//! while still being able to share underlying implementations (from the `lib/`
//! module), and without the overhead of having to manually keep our list of
//! binaries updated as the routes evolve.

use std::fmt::Write;
use std::fs::File;
use std::io::{BufRead, BufReader};

use walkdir::{DirEntry, WalkDir};

const ROUTES_DIR_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/routes");
const MANIFEST_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");

const AUTOGENERATED_BOUNDARY_ABOVE: &str = "# -- AUTOGENERATED: Route Handler Binaries (Below)";
const AUTOGENERATED_BOUNDARY_BELOW: &str = "# -- AUTOGENERATED: Route Handler Binaries (Above)";

const HTTP_METHODS: [&str; 4] = ["DELETE", "GET", "POST", "PUT"];

/// Represents a route binary which we want to ask Cargo to build for us.
struct Route {
    /// The name which should be specified to Cargo for the built route binary.
    name: String,
    /// The path to the route binary, as it should be passed to Cargo (hence
    /// relative to the project root).
    path: String,
}

impl Route {
    /// Attempts to convert the given directory entry into a `Route`, based on
    /// the following assumptions:
    ///
    /// 1. The path to this entry defines the endpoint for that route.
    /// 2. The entry's name is the HTTP method which this route defines.
    ///
    /// For example, a file at `/v1/users/get.rs` would define a `GET /v1/users`
    /// route.
    ///
    /// Returns `None` if the entry doesn't correspond to a route (e.g. it's a
    /// directory, it's not a Rust source file, ...).
    fn from_dir_entry(entry: DirEntry) -> Option<Self> {
        if entry.file_type().is_dir() {
            return None;
        }

        let path = entry.path();
        let is_rust_source_file = path
            .extension()
            .map_or(false, |extension| extension == "rs");
        if !is_rust_source_file {
            println!("cargo::warning=Routes directory contains an unexpected file: {path:?}");
            return None;
        }

        let file_name = path
            .file_stem()
            .expect("routes directory contains a file with no name")
            .to_str()
            .expect("routes directory contains a file with a non-unicode filename");
        let is_valid_http_method = HTTP_METHODS
            .into_iter()
            .any(|method| method.to_lowercase() == file_name);
        if !is_valid_http_method {
            println!("cargo::warning=Routes directory contains a source file which doesn't define a valid HTTP method: {path:?}");
            return None;
        }
        // Just renaming the variable now that we've confirmed what is is.
        let http_method = file_name;

        let mut name = path
            .parent()
            .expect("directory entry doesn't have a parent directory")
            .strip_prefix(ROUTES_DIR_PATH)
            .expect("directory entry isn't inside the routes directory")
            .to_str()
            .expect("directory entry path isn't unicode")
            // Cargo binary names can't contain slashes
            .replace(std::path::MAIN_SEPARATOR, "-");
        // See https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field
        //
        // This loses some information which means we could end up with conflicts, but
        // if that happens we rely on Cargo to complain about duplicate binary
        // names at build time (in which case this script might need to be
        // updated as necessary).
        name.retain(|c| c == '-' || c.is_alphanumeric());
        let name = format!("route-{name}-{http_method}");

        let path = path
            .strip_prefix(env!("CARGO_MANIFEST_DIR"))
            .expect("directory entry should be inside the project")
            .to_str()
            .expect("directory entry path should be unicode")
            .to_string();

        Some(Self { name, path })
    }
}

fn main() {
    if option_env!("CARGO_PRIMARY_PACKAGE").is_none() {
        // We're being built as a dependency of a downstream package, let's not mess
        // with any manifests...
        return;
        // This shouldn't happen as this package isn't distributed as a library
        // for external consumption and use as a dependency, but it
        // doesn't do any harm putting this here to avoid breaking
        // downstream builds if this ever changes.
    }

    let manifest_old = File::open(MANIFEST_PATH).expect("failed to read Cargo.toml");

    let manifest_size = manifest_old
        .metadata()
        .expect("failed to read Cargo.toml file metadata")
        .len()
        .try_into()
        .expect("Cargo.toml file size did not fit within u64 bounds");
    // Write the new manifest to a string in-memory so that we can swap it
    // atomically only once we know we've built it successfully.
    let mut manifest_new = String::with_capacity(manifest_size);

    let mut manifest_lines = BufReader::new(manifest_old)
        .lines()
        .map(|line| line.expect("failed to read contents of Cargo.toml"));

    // Lines before we auto-generate anything (un-altered):

    for line in manifest_lines
        .by_ref()
        .take_while(|line| line != AUTOGENERATED_BOUNDARY_ABOVE)
    {
        writeln!(manifest_new, "{line}").unwrap();
    }
    // The .take_while() consumed the AUTOGENERATED_BOUNDARY_ABOVE line, but we
    // didn't write it.
    writeln!(manifest_new, "{AUTOGENERATED_BOUNDARY_ABOVE}").unwrap();

    // Auto-generated lines:

    let routes = WalkDir::new(ROUTES_DIR_PATH)
        // Avoids our Cargo.toml changing non-deterministically across builds
        .sort_by_file_name()
        .into_iter()
        .map(|entry| entry.expect("unable to read contents of routes directory"))
        .filter_map(Route::from_dir_entry);
    for route in routes {
        dbg!(&route.name, &route.path);
        writeln!(manifest_new, "[[bin]]").unwrap();
        writeln!(manifest_new, "name = {:?}", route.name).unwrap();
        writeln!(manifest_new, "path = {:?}", route.path).unwrap();
    }

    // Lines after we auto-generate anything (un-altered):

    let below_boundary = manifest_lines
        .find(|line| line == AUTOGENERATED_BOUNDARY_BELOW)
        // If no "below" boundary was found, then we want to abort as we run the risk of overwriting
        // real lines inside the manifest (anything which the user might have left below the "above"
        // boundary).
        .expect("manifest is missing a fenced section for route binaries");
    writeln!(manifest_new, "{below_boundary}").unwrap();
    // The .any() will have consumed all lines between the "above" / "below" fences.
    for line in manifest_lines {
        writeln!(manifest_new, "{line}").unwrap();
    }

    std::fs::write(MANIFEST_PATH, manifest_new)
        .expect("failed to overwrite contents of Cargo.toml");

    // See https://doc.rust-lang.org/cargo/reference/build-scripts.html#rerun-if-changed
    // > If the path points to a directory, it will scan the entire directory for
    // > any modifications.
    println!("cargo::rerun-if-changed={ROUTES_DIR_PATH}");
}
