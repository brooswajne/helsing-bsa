import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Iterator

import pulumi
import tomllib
from pulumi_aws import iam, lambda_
from pulumi_aws_apigateway import Method, RouteArgs

from src.naming import namespace

AUTOGENERATED_BOUNDARY_ABOVE = "# -- AUTOGENERATED: Route Handler Binaries (Below)"
AUTOGENERATED_BOUNDARY_BELOW = "# -- AUTOGENERATED: Route Handler Binaries (Above)"


def create_routes_from_rust_project(project_root: Path) -> Iterator[RouteArgs]:
    # TODO: This should ideally only be for development use. In CI, we should
    # take the path to the pre-built binaries as input (so that the binaries
    # which we're deploying are exactly the same as those which we've archived
    # as CI build artifacts).
    project_build_output_dir = build_rust_project_to_lambdas(project_root)

    route_binary_definitions = read_route_binary_definitions_from_rust_project(project_root)
    routes_root_directory = project_root.joinpath("routes")

    for definition in route_binary_definitions:
        # We've defined our file-based routing mechanism such that a file at
        # path `routes/v1/users/get.rs` defines a route at `GET /v1/users`:
        path = (
            "/" if definition.path.parent == routes_root_directory
            else definition.path.parent.relative_to(routes_root_directory).as_posix()
        )
        method = Method(definition.path.stem.upper())

        binary_path = project_build_output_dir.joinpath(definition.name)
        handler_function = create_rust_lambda_function(
            name = definition.name,
            binary = binary_path,
        )

        yield RouteArgs(path = path, method = method, event_handler = handler_function)


def build_rust_project_to_lambdas(project_root: Path) -> Path:
    try:
        subprocess.run(
            cwd = project_root,
            args = [ "cargo", "lambda", "build", "--release", "--arm64" ],
            capture_output = True,
            check = True,
        )
    except subprocess.CalledProcessError as e:
        output = e.stderr or e.stdout
        raise Exception(f"Failed to build Rust project {project_root}: {repr(output)}") from e
    return project_root.joinpath("target/lambda")


@dataclass
class RustBinaryDefinition:
    """ A parsed [[bin]] definition as read from a Rust project's Cargo.toml. """
    name: str
    path: Path


def read_route_binary_definitions_from_rust_project(project_root: Path) -> Iterator[RustBinaryDefinition]:
    manifest_path = project_root.joinpath("Cargo.toml")

    with manifest_path.open() as manifest:
        binary_definitions = ""
        try:
            while next(manifest).strip() != AUTOGENERATED_BOUNDARY_ABOVE: pass
            while (line := next(manifest)).strip() != AUTOGENERATED_BOUNDARY_BELOW:
                binary_definitions += line
        except StopIteration:
            raise Exception(f"Manifest {manifest_path} is missing an auto-generated route definitions section")

    try:
        binary_definitions = tomllib.loads(binary_definitions)["bin"]
    except Exception as e:
        raise Exception(f"Manifest {manifest_path} has an invalid auto-generated route definitions section") from e

    for definition in binary_definitions:
        try:
            yield RustBinaryDefinition(
                name = definition["name"],
                path = project_root.joinpath(definition["path"]),
            )
        except KeyError as e:
            raise Exception(f"Manifest {manifest_path} has an invalid auto-generated route definitions section") from e


def create_rust_lambda_function(name: str, binary: Path) -> lambda_.Function:
    role = create_role_which_can_be_assumed_by_lambda_functions(name)

    return lambda_.Function(
        resource_name = namespace(name),
        code = pulumi.FileArchive(binary.as_posix()),
        role = role.arn,
        handler = "handler",
        runtime = "provided.al2023",
        architectures = [ "arm64" ],
    )

def create_role_which_can_be_assumed_by_lambda_functions(name: str) -> iam.Role:
    role = iam.Role(
        resource_name = namespace(name),
        assume_role_policy = pulumi.Output.json_dumps({
            "Version": "2012-10-17",
            "Statement": [ {
                "Effect": "Allow",
                "Principal": { "Service": "lambda.amazonaws.com" },
                "Action": "sts:AssumeRole",
            } ],
        }),
    )

    # Allows the Lambda to write logs to CloudWatch
    iam.RolePolicyAttachment(
        resource_name = namespace(name),
        role = role.name,
        policy_arn = iam.get_policy("arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole").arn,
        opts = pulumi.ResourceOptions(parent = role),
    )

    return role
